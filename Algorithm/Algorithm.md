
### 总览
10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

### Tips
- 空间换时间：双向链表

### 学习方法
1. 一定动手实践，在LeetCode上寻找类似的题目分散思维，适度刷题
2. 学习“来历”，自身的特点，适合解决的问题，实际的应用场景
2. 多看，多思考
3. 学习三遍以上

### 复杂度分析
#### 为什么需要复杂度分析
1. 算法的测试结果和硬件环境关联性很大，性能好的机器明显会比性能差的机器执行时间短
2. 算法的测试结果和数据的规模影响很大
#### 时间空间复杂度 
- (渐进)时间复杂度：算法的执行时间随数据规模增长的变化趋势，T(n)=O(f(n))，T(n)代表了算法的执行时间，O表示了正比的关系，f(n)表示了算法执行的行数，规定每行代码执行的时间是相同的，为1个unit_time
- 空间复杂度：算法的存储空间与数据规模之间的增长关系
#### 时间复杂度分类
- 平均时间复杂度：罗列操作可能的执行情况，分别乘上各自的概率得到准确的时间复杂度
- 均摊时间复杂度：对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度很高，并且这些操作之间存在明显的前后连贯时序关系，可以将这些操作放到一起分析，一般均摊时间复杂度等于最好情况时间复杂度

### 数组
- 数组支持随机访问，根据下标随机访问数据的时间复杂度为O(1)，但是插入和删除数据很低效
- 针对数组类型，很多高级语言都提供了容器类，如Java的ArrayList，容器类将很多数组操作的细节封装了起来，并且提供了动态扩容
#### 什么时候使用原生的数组而不是容器类？
1. ArrayList无法存储基本类型，都是包装类型，而Autoboxing、Unboxing还是有性能消耗的，如果对于性能要求高，则用数组
2. 如果数组的大小事先已经知道了，并且操作简单，那么用数组
3. 多维数组，数组比较直观
#### 数组的下标为什么从0开始？
- 假设从1开始，那么根据i随机访问数组中的元素时是这样计算的：add=base_add+(i-1)*type_size,会比从0开始多了一次减法操作
- 历史遗留问题

### 链表
- 有“哨兵”的链表，能够简化操作逻辑，有哨兵节点的链表称为带头链表，没有的称为不带头链表，在插入排序、归并排序、动态规划等也有用到哨兵
- 注意边界条件：当链表为空，当链表只有一个节点，当链表只有两个节点，头尾节点处理等

### 栈
- 操作受限的线性表
- 应用场景：表达式求值、函数调用、括号匹配

### 递归
#### 包含以下3点可以使用递归算法来解决
- 一个问题可以分解为多个子问题
- 这个问题和子问题的求解思路是一样的，只是数据规模不同
- 存在递归终止条件
#### 递归容易导致的问题
空间复杂度高，重复计算，堆栈溢出，函数调用累计导致时间复杂度高

#### 怎么实现递归算法
- 不要被绕进去，要在子问题已经解决的情况下，思考问题之间的联系，确定终止条件
- 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码