
### 总览
10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

### Tips
- 空间换时间：双向链表

### 学习方法
1. 一定动手实践，在LeetCode上寻找类似的题目分散思维，适度刷题
2. 学习“来历”，自身的特点，适合解决的问题，实际的应用场景
2. 多看，多思考
3. 学习三遍以上

### 复杂度分析
#### 为什么需要复杂度分析
1. 算法的测试结果和硬件环境关联性很大，性能好的机器明显会比性能差的机器执行时间短
2. 算法的测试结果和数据的规模影响很大
#### 时间空间复杂度 
- (渐进)时间复杂度：算法的执行时间随数据规模增长的变化趋势，T(n)=O(f(n))，T(n)代表了算法的执行时间，O表示了正比的关系，f(n)表示了算法执行的行数，规定每行代码执行的时间是相同的，为1个unit_time
- 空间复杂度：算法的存储空间与数据规模之间的增长关系
#### 时间复杂度分类
- 平均时间复杂度：罗列操作可能的执行情况，分别乘上各自的概率得到准确的时间复杂度
- 均摊时间复杂度：对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度很高，并且这些操作之间存在明显的前后连贯时序关系，可以将这些操作放到一起分析，一般均摊时间复杂度等于最好情况时间复杂度

### 数组
- 数组支持随机访问，根据下标随机访问数据的时间复杂度为O(1)，但是插入和删除数据很低效
- 针对数组类型，很多高级语言都提供了容器类，如Java的ArrayList，容器类将很多数组操作的细节封装了起来，并且提供了动态扩容
#### 什么时候使用原生的数组而不是容器类？
1. ArrayList无法存储基本类型，都是包装类型，而Autoboxing、Unboxing还是有性能消耗的，如果对于性能要求高，则用数组
2. 如果数组的大小事先已经知道了，并且操作简单，那么用数组
3. 多维数组，数组比较直观
#### 数组的下标为什么从0开始？
- 假设从1开始，那么根据i随机访问数组中的元素时是这样计算的：add=base_add+(i-1)*type_size,会比从0开始多了一次减法操作
- 历史遗留问题

### 链表
- 有“哨兵”的链表，能够简化操作逻辑，有哨兵节点的链表称为带头链表，没有的称为不带头链表，在插入排序、归并排序、动态规划等也有用到哨兵
- 注意边界条件：当链表为空，当链表只有一个节点，当链表只有两个节点，头尾节点处理等

### 栈
- 操作受限的线性表
- 应用场景：表达式求值、函数调用、括号匹配

### 递归
#### 包含以下3点可以使用递归算法来解决
- 一个问题可以分解为多个子问题
- 这个问题和子问题的求解思路是一样的，只是数据规模不同
- 存在递归终止条件
#### 递归容易导致的问题
空间复杂度高，重复计算，堆栈溢出，函数调用累计导致时间复杂度高

#### 怎么实现递归算法
- 不要被绕进去，要在子问题已经解决的情况下，思考问题之间的联系，确定终止条件
- 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码


### 排序算法
#### 排序算法执行效率分析考虑以下
1. 最好情况、最差情况、平均情况时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 比较次数和交换（移动）次数
4. 是否是原地排序(空间复杂度是O(1))，是否是稳定排序(对于相同值的元素，排序前后其前后顺序没有变化)

#### 冒泡排序
- 是原地排序，是稳定排序
包含了两个原子操作，比较和交换，交换平均复杂度的分析考虑有序度，最好情况下有序度为满有序度为`n*(n-1)/2`，交换次数为0，最差情况下有序度为0，交换次数为`n*(n-1)/2`，平均下来交换次数为n*(n-1)/4，比较操作比交换操作多得多，而复杂度的上限为O(n^2)，所以平均下来冒泡排序的时间复杂度为O(n^2)
#### 插入排序
- 是原地排序，是稳定排序
- 数组分为已排序区和未排序区，每次从未排序区取一个数据，插入到已排序区的合适位置

#### 选择排序
- 是原地排序，不是稳定排序
- 数组分为已排序区和未排序区，每次从未排序区区最小的数，放置到已排序区的最后的位置

#### Bucket Sort
桶排序比较适合用于外部排序(数据存储在外部硬盘中，数据量比较大，内存有限，无法一次性将数据加载到内存)中
#### Count Sort
适合在数据范围不大的情况下，而且数值只能为非负数
#### Radix Sort
数据需要可以单独分割出独立的位进行比较，并且位之间有递进的关系，每一位的数据范围不能很大，要能够用O(n)进行稳定排序

#### 冒泡排序和插入排序
冒泡排序和插入排序对于同一个数据，其交换数据的次数都是一样的，都是逆序度，但是两者在交换数据的操作存在细微的差别，冒泡排序中的数据交换操作会比插入排序的要多，冒泡排序需要3个赋值操作，而插入排序只有1个赋值操作
```
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```
#### 一个通用的、高性能的排序函数
如果数据量不大，使用归并排序，数据量超过阈值则用快速排序，当快排的长度减小到一定阈值的时候用插入排序
