
### 总览
10 个数据结构：数组、链表、栈、队列、散列表、二叉树、堆、跳表、图、Trie 树；
10 个算法：递归、排序、二分查找、搜索、哈希算法、贪心算法、分治算法、回溯算法、动态规划、字符串匹配算法。

### Tips
- 空间换时间：双向链表

### 学习方法
1. 一定动手实践，在LeetCode上寻找类似的题目分散思维，适度刷题
2. 学习“来历”，自身的特点，适合解决的问题，实际的应用场景
2. 多看，多思考
3. 学习三遍以上

### 复杂度分析
#### 为什么需要复杂度分析
1. 算法的测试结果和硬件环境关联性很大，性能好的机器明显会比性能差的机器执行时间短
2. 算法的测试结果和数据的规模影响很大
#### 时间空间复杂度 
- (渐进)时间复杂度：算法的执行时间随数据规模增长的变化趋势，T(n)=O(f(n))，T(n)代表了算法的执行时间，O表示了正比的关系，f(n)表示了算法执行的行数，规定每行代码执行的时间是相同的，为1个unit_time
- 空间复杂度：算法的存储空间与数据规模之间的增长关系
#### 时间复杂度分类
- 平均时间复杂度：罗列操作可能的执行情况，分别乘上各自的概率得到准确的时间复杂度
- 均摊时间复杂度：对一个数据结构进行一组连续的操作中，大部分情况下时间复杂度都很低，只有个别情况下时间复杂度很高，并且这些操作之间存在明显的前后连贯时序关系，可以将这些操作放到一起分析，一般均摊时间复杂度等于最好情况时间复杂度

### 数组
- 数组支持随机访问，根据下标随机访问数据的时间复杂度为O(1)，但是插入和删除数据很低效
- 针对数组类型，很多高级语言都提供了容器类，如Java的ArrayList，容器类将很多数组操作的细节封装了起来，并且提供了动态扩容
#### 什么时候使用原生的数组而不是容器类？
1. ArrayList无法存储基本类型，都是包装类型，而Autoboxing、Unboxing还是有性能消耗的，如果对于性能要求高，则用数组
2. 如果数组的大小事先已经知道了，并且操作简单，那么用数组
3. 多维数组，数组比较直观
#### 数组的下标为什么从0开始？
- 假设从1开始，那么根据i随机访问数组中的元素时是这样计算的：add=base_add+(i-1)*type_size,会比从0开始多了一次减法操作
- 历史遗留问题

### 链表
- 有“哨兵”的链表，能够简化操作逻辑，有哨兵节点的链表称为带头链表，没有的称为不带头链表，在插入排序、归并排序、动态规划等也有用到哨兵
- 注意边界条件：当链表为空，当链表只有一个节点，当链表只有两个节点，头尾节点处理等

### 栈
- 操作受限的线性表
- 应用场景：表达式求值、函数调用、括号匹配

### 递归
#### 包含以下3点可以使用递归算法来解决
- 一个问题可以分解为多个子问题
- 这个问题和子问题的求解思路是一样的，只是数据规模不同
- 存在递归终止条件
#### 递归容易导致的问题
空间复杂度高，重复计算，堆栈溢出，函数调用累计导致时间复杂度高

#### 怎么实现递归算法
- 不要被绕进去，要在子问题已经解决的情况下，思考问题之间的联系，确定终止条件
- 写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码


### 排序算法
#### 排序算法执行效率分析考虑以下
1. 最好情况、最差情况、平均情况时间复杂度
2. 时间复杂度的系数、常数、低阶
3. 比较次数和交换（移动）次数
4. 是否是原地排序(空间复杂度是O(1))，是否是稳定排序(对于相同值的元素，排序前后其前后顺序没有变化)

#### 冒泡排序
- 是原地排序，是稳定排序
包含了两个原子操作，比较和交换，交换平均复杂度的分析考虑有序度，最好情况下有序度为满有序度为`n*(n-1)/2`，交换次数为0，最差情况下有序度为0，交换次数为`n*(n-1)/2`，平均下来交换次数为n*(n-1)/4，比较操作比交换操作多得多，而复杂度的上限为O(n^2)，所以平均下来冒泡排序的时间复杂度为O(n^2)
#### 插入排序
- 是原地排序，是稳定排序
- 数组分为已排序区和未排序区，每次从未排序区取一个数据，插入到已排序区的合适位置

#### 选择排序
- 是原地排序，不是稳定排序
- 数组分为已排序区和未排序区，每次从未排序区区最小的数，放置到已排序区的最后的位置

#### Bucket Sort
桶排序比较适合用于外部排序(数据存储在外部硬盘中，数据量比较大，内存有限，无法一次性将数据加载到内存)中
#### Count Sort
适合在数据范围不大的情况下，而且数值只能为非负数
#### Radix Sort
数据需要可以单独分割出独立的位进行比较，并且位之间有递进的关系，每一位的数据范围不能很大，要能够用O(n)进行稳定排序

#### 冒泡排序和插入排序
冒泡排序和插入排序对于同一个数据，其交换数据的次数都是一样的，都是逆序度，但是两者在交换数据的操作存在细微的差别，冒泡排序中的数据交换操作会比插入排序的要多，冒泡排序需要3个赋值操作，而插入排序只有1个赋值操作
```
冒泡排序中数据的交换操作：
if (a[j] > a[j+1]) { // 交换
   int tmp = a[j];
   a[j] = a[j+1];
   a[j+1] = tmp;
   flag = true;
}

插入排序中数据的移动操作：
if (a[j] > value) {
  a[j+1] = a[j];  // 数据移动
} else {
  break;
}
```
#### 一个通用的、高性能的排序函数
如果数据量不大，使用归并排序，数据量超过阈值则用快速排序，当快排的长度减小到一定阈值的时候用插入排序

### 二分查找
- 数据结构依赖数组
- 数据需要是有序的
- 数据量太小不需要使用二分查找，数据量太大的话也不适合，因为需要顺序数组，内存中不一定存在满足条件的存储空间
- 用二分查找可以解决的问题，用散列表、二叉树都可以解决，但是这两个数据结构需要占用较多额外的内存空间
- 二分查找的数据最好是静态数据，如果有频繁的增删操作，需要维护数据的有序性，不如使用其他数据结构

### SkipList
skiplist的查找、删除、增加数据的时间复杂度和红黑树一样都是O(logn)，不过区间查询skiplist比红黑树要快，所以Resdis使用skiplist而不是红黑树

### Hash Table
- 散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。
- 散列表扩容的时候，避免一次性完成，而是分成多次完成，因此存在旧的散列表和新的散列表之间的操作
- 散列表总是和链表一起使用更加高效
- 散列表扩容的时候，为了避免一次性扩容导致服务器无法响应其他的服务，不是一次性将旧表中的数据复制到新表中，而是在这段时间内存在两个散列表，新来的数据直接放置在新表中，同时从旧表中选择一个加入到新表，查询的时候从新表开始查询，没有的话再去旧表查询，将扩容的操作均摊。

#### 冲突情况处理
> 开放寻址法
- 包括了线性探测发，二次探测法，双重散列法等
- 装载因子越大说明空闲位置越少，冲突越多，散列表的性能越低
- 优点：散列表的数据都存储在数组中，能够有效利用CPU的缓存；序列化更加简单（链表法包含了指针）
- 缺点：删除数据比较麻烦；冲突的代价更高，因此装载因子的上限不能太大，比链表法会更浪费空间
- 适用场景：数据量小，装载因子小的时候

> 链表法
- 优点：内存利用率更高，装载因子可以很高（如10）
- 缺点：对CPU缓存不友好；对于小对象，由于需要另外存储指针，所以内存消耗更高
- 适用场景：存储大对象、大数据量的时候
- 当保存的不是单纯的数字，而是字符串的时候，需要将字符串和链表中的每个字符串一一对比，这儿容易产生瓶颈


### 基本的算法思想
#### 贪心算法
- 针对一组数据，如果我们定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大
- 在每次进行选择的时候，选择对当前期望值最大的的数据
- 贪心算法并不总能给出最优解
- 霍夫曼编码（Huffman Coding）、Prim 和 Kruskal 最小生成树算法、还有 Dijkstra 单源最短路径算法。

#### 分治算法
- 将原问题划分为n个规模更小的子问题，子问题和原问题的结构是相似的，递归的解决子问题后就能得到原问题的解
- 分治算法是处理问题的思想，递归是编程技巧，一般来说分治算法适合用递归来实现
- 原问题与分解成的小问题具有相同的模式
- 原问题分解成的子问题可以独立求解，子问题之间没有相关性，这是和动态规划不一样的地方
- 具有分解终止条件
- 可以将子问题合并成为原问题，并且这个合并操作的复杂度不能太高

#### 回溯算法
- 我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免重复和遗漏，我们把问题求解的过程分成多个阶段，每个阶段都有多种选择，我们“随意”选择一条道路，当发现这条路走到尽头或者走不通(不符合期望的解)，就回退一步到上一阶段，选择另外的道路继续走。
- 算法很多时候都应用在“搜索”问题上，搜索满足期望的解
- 时间复杂度一般都是指数级别的
- 数独、八皇后、0-1 背包、图的着色、旅行商问题、全排列

#### 动态规划
##### 什么样的问题适合用动态规划来解决
- 多阶段决策最优解模型：解决问题的过程，需要经过多个决策阶段，每个决策阶段对应一组状态，然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值
- 最优子结构：我们可以通过子问题的最优解，推导出问题的最优解，换句话说就是，后面阶段的状态可以通过前面一个阶段的状态推导出来
- 重复子问题：不同的决策序列，到达某个相同的决策阶段的时候，可能会产生重复的状态(对比与分治算法，分治算法要求分割成的子问题，不能有重复子问题)
- 无后效性：第一，我们在推导后面阶段的状态时候，只关心前一个阶段的状态，而不用关心前一个阶段的状态使怎么推导出来的；第二，某阶段一旦确定，就不受之后阶段的决策影响

#### 枚举算法

### 霍夫曼编码
- 对于要处理的字符串，不仅考虑字符有多少种，而且考虑每个字符出现的频率，将出现频率高的字符编码成较短
- 对于各个字符编码之间，不会出现某个编码是另一个编码的前缀，因为霍夫曼编码每个字符是不等长编码的
- 怎么编码？霍夫曼树