### MySQL架构
![image](https://github.com/Default-loves/My-Computer-Path/blob/master/pic/MySQL/MySQL%E6%9E%B6%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
- Server层包括了连接器、分析器、优化器、执行器，所有跨存储引擎的功能都在这一层
- 存储引擎负责数据的读取和存储，其架构模式是插件式的，支持InnoDB，MyISAM，Memory等存储引擎
#### 连接器
- 连接器用于和客户端建立连接，获取登陆用户的权限，维持和管理连接
- 建立连接后，使用的权限将固定下来
- 对于长连接，由于查询过程中临时使用的内存管理于连接对象中，只有断开连接的时候才释放内存资源，所以如果连接长时间保持，则内存占用大，对此，有两种解决方法：
1. 定期断开连接，或者程序里面判断如果操作了一个占用内存的大查询后，断开连接，之后要查询的时候重新连接
2. 在每次执行完一次大查询后，执行`mysql_reset_connection`来重新初始化连接，这个过程不需要重新获取权限和重连，只是将连接恢复到原始的状态

#### 分析器
包括词法分析，语法分析

#### 优化器
在表里面有多个索引的时候，决定使用哪个索引更快，或者在多表连接join的时候，决定表的连接顺序，优化器的目的是对于多个索引，找到执行代价最小的方案去执行，影响执行代价的元素包括：扫描行数、是否涉及到临时表和排序等

#### 执行器
首先判断对表是否有执行的权限，如果没有操作权限就报错，之后调用存储引擎接口来进行操作，在数据库的慢查询日志中有rows_examined字段，表示了语句执行过程中执行器调用存储引擎获取数据行的时候累加的

### 日志系统
更新数据会设计到两个重要日志模块，redo log（重做日志）和binlog（归档日志）

#### WAL(Write-ahead logging，预写式日志）
是关系数据库中用来保证原子性和持久性的一系列技术，在数据修改提交之前都需要将更新操作先写入log中，再写磁盘，log文件通常包括redo和undo信息，具备crash-safe

#### redo log
- 是物理日志，意思是记录的内容是更新操作对具体的数据页进行的操作
- 存在于InnoDB存储引擎中
- 大小是固定的，循环写，write pos指向写入的位置，checkpoint指向需要更新数据到磁盘的位置
- 由于在硬盘中对数据进行更新耗费时间很久，所以将更新操作记录在redo log中，通常在系统空闲的时候读取redo log进行磁盘写入,这个过程称为`flush`
- 大小是固定的，比如4个各2G的文件，循环写入redo log，因此当redo log满时，需要等待flush过程，此时系统不能更新数据
- crash-safe，在系统异常重启后，保证了数据的一致性，也就是说之前提交记录不会丢失

#### binlog
- 是逻辑日志，当中的内容是更新操作对查找数据字段的值修改多少，多是SQL语句
- 存在于Server层中
- 追加写
- 主要用于存储全部的更新操作记录，用于重现历史时刻

#### 日志的记录过程
当对数据进行更新操作的时候，执行器通过存储引擎接口获取到行数据，在内存中对数据进行修改后，通知存储引擎进行redo log，此时的状态为prepare，执行再进行binlog，紧接着存储引擎将相应的redo log状态变为commit，此为两阶段提交

### 事务
- SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serializable ）。
- 在实现上，事务隔离的具体实现是使用视图（read-view），可重复读是在事务开始的时候创建视图，读提交是在sql语句执行前重新算出一个新的视图，读未提交直接返回记录的最新值，串行化是加锁
- 在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。
- 回滚日志不会一直保留，当没有事务需要使用这些回滚日志的时候，回滚日志会被删除，当系统里没有比这个回滚日志更早的read-view的时候为不需要的回滚日志
- 长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。

#### 事务的启动方式
1. 显示启动，`begin`或`start transaction`，提交`commit`，回滚`rollback`
2. `set autocommit=0`,意味着只执行一个`select`，事务就会启动，直到`commit`或者`rollback`,或者断开连接

`commit work and chain`:在`autocommit`为1的情况下，则效果为提交事务并且自动启动下一个事务

`begin/start transaction`命令并不是一个事务的起点，在执行第一个操作InnoDB表语句时，事务才真正启动；而`start transaction with consistent snapshot`则是马上启动一个事务
